Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для управління складом

Студент гр. ПЗПІ-21-2	__________________ Буцулін І. О.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст. викл. Сокорчук І.П.
(підпис)



Харків 
2024 р. 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6		          	____        
Навчальна дисципліна Архітектура програмного забезпечення	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Буцуліну Ігорю Олександровичу
1.	Тема роботи: «Програмна система для управління складом»	
2.	Термін узгодження завдання курсової роботи «26» лютого 2024 р.
3.	Термін здачі студентом закінченої роботи «31» травня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити: дотримання критеріїв оригінальністі, монетизації, актуальності проблематики, орієнтації на широке коло користувачів, масштабованісті та включити серверну, клієнтську частини, мобільний та застосунок для вбудованих систем. Використовувати ОС Windows 11, СКБД PostgreSQL, середовище розробки Goland, WebStorm, Android Studio.	
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
Вступ, аналіз та концептуальне моделювання предметної області, опис розробки серверної частини системи, опис розробки застосунку для вбудованих систем, опис розробки клієнтської частини системи, опис розробки мобільної частини системи, висновки, перелік використаних джерел, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) ER-модель даних, UML діаграма прецедентів, UML діаграма компонент, UML діаграма взаємодії, UML діаграма діяльності, UML діаграма пакетів, UML діаграма розгортання	
КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	26.02.24 – 22.03.24	виконано
2	Проектування програмного
проекту	22.03.24 – 12.04.24	виконано
3	Кодування програмного проекту	12.04.24 – 26.04.24	виконано
4	Оформлення пояснювальної
записки	26.04.24 - 17.05.24	виконано
5	Захист курсової роботи	17.05.24 – 31.05.24	виконано

Дата видачі завдання «26» лютого 2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________                Буцулін І. О.
(підпис)


 
РЕФЕРАТ


Пояснювальна записка: 50 ст., 7 рис., 2 дод., 5 джерел.
СКЛАД, ARDUINO, ESP32, GO, JETPACK COMPOSE, KOTLIN, REACT, POSTGRESQL.
Метою курсового проекту є автоматизація та оптимізація управління складськими приміщеннями програмними засобами для ефективного використання ресурсів, пов'язаних з поставкою, переміщенням та відправкою товарів у межах та за межами складських приміщень. Процес розробки додатку включає в себе аналіз та концептуальне моделювання предметної області, проектування бази даних, побудову серверної частини застосунку, розробку частини системи для вбудованих систем, створення мобільного та веб-застосунку.
Результатом роботи стала програмна система для управління складом, що складається з серверної, клієнтської, мобільної частин та частини для вбудованих систем. 
В процесі розробки застосовувалися різноманітні технології, зокрема бібліотека Chi для Go, СКБД PostgreSQL, клієнтська бібліотека React для Typescript, Arduino SDK для ESP32, фреймворк Jetpack Compose для Kotlin. У якості середовищ розробки використовувалися Jetbrains Goland, Jetbrains Webstorm, Google Android Studio та Wokwi.

 
ЗМІСТ


Вступ	7
1 Аналіз та концептуальне моделювання предметної області	8
1.1 Бізнес-можливості	8
1.2 Аналіз існуючих аналогів	8
1.3 Головна функціональність	9
1.4 Робоче середовище	11
2 Опис розробки серверної частини системи	12
2.1 Побудова ER-моделі даних	12
2.2 Опис архітектури серверної частини програмної системи	13
2.3 Опис взаємодії з іншими частинами системи	14
2.4 Опис структури коду серверної частини системи	15
2.5 Специфікація REST	16
3 Опис розробки застосунку для вбудовних систем	18
3.1 Концептуальне моделювання застосунку	18
3.2 Обґрунтування архітектурних рішень	18
3.3 Опис використаних технологій	19
3.4 Опис результатів розробки застосунку для вбудованих систем	20
3.5 Опис результатів тестування застосунку для вбудованих систем	21
4 Опис розробки клієнтської частини системи	22
4.1 Концептуальне моделювання застосунку	22
4.2 Обґрунтування архітектурних рішень	22
4.3 Опис використаних технологій	23
4.4 Опис результатів розробки клієнтської частини системи	23
4.5 Опис результатів тестування клієнтської частини системи	24
5 Опис розробки мобільної частини системи	25
5.1 Концептуальне моделювання застосунку	25
5.2 Обґрунтування архітектурних рішень	25
5.3 Опис використаних технологій	26
5.4 Опис результатів розробки мобільного застосунку	26
5.5 Опис результатів тестування мобільного застосунку	27
Висновки	28
Перелік використаних джерел	29
Додаток А	30
Додаток Б	37
Б.1 Стартовий файл серверної частини системи	37
Б.2 Файл сервісу аутентифікації серверної частини системи	40
Б.3 Частина коду доступу до бази даних серверної частини системи	41
Б.4 Код cтруктури «Користувач» серверної частини системи	42
Б.5 Ініціалізація програми застосунку для вбудованих систем	43
Б.6 Головний цикл застосунку для вбудованих систем	43
Б.7 Конфігураційний файл застосунку для вбудованих систем	44
Б.8 Ініціалізація клієнтської частини системи	44
Б.9 Головний компонент клієнтської частини системи	45
Б.10 Ініціалізація мобільної частини системи	46
Б.11 Головний компонент мобільної частини системи	48

 
ВСТУП


Внаслідок розвитку торгівлі та її глобалізації, нині має місце високе логістичне навантаження на ринок товарів. Для управління переміщенням великої кількості товарів необхідним стає ефективний контроль поставок, переміщень та відправок товарів у межах та за межами складу. Ця проблема загострилася під час військового стану, оскільки завдання щодо зберігання та переміщення великої кількості товарів постали перед різноманітними волонтерськими організаціями та Міністерством оборони. Відповідно, виникає потреба у автоматизації та оптимізації управління складом. Виникає запит до створення системи управління складом, що буде мати ефективне журналювання подій, розділення обов’язків. 
Підсумовуючи усе вищезазначене, метою роботи є автоматизація та оптимізація управління складськими приміщеннями програмними засобами для ефективного використання ресурсів, пов'язаних з поставкою, переміщенням та відправкою товарів у межах та за межами складських приміщень.
Результатом роботи стала програмна система для управління складом, що складається з серверної, клієнтської, мобільної частин та частини для вбудованих систем. 
В процесі розробки застосовувалися різноманітні технології, зокрема бібліотека Chi для Go, СКБД PostgreSQL, клієнтська бібліотека React для Typescript, Arduino SDK для ESP32, фреймворк Jetpack Compose для Kotlin. У якості середовищ розробки використовувалися Jetbrains Goland, Jetbrains Webstorm, Google Android Studio та Wokwi.
 
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-можливості


Продукт орієнтується на ринок систем керування складом (WMS), який може виявитися перспективним, оскільки багато організацій прагнуть покращити ефективність логістики. Цей ринок швидко розвивається, і має потенціал для зростання.
Продукт орієнтується на глобальний ринок, зокрема на розвинуті демократичні країни Європи, Австралії та Північної Америки. Ці країни є економічно стабільними та перспективними з точки зору потенційних інвестицій.
У якості принципів монетизації планується отримання роялті від виробника кінцевого пристрою, а також укладання партнерських угод з корпоративними клієнтами про надання та встановлення програмного продукту та сервісної підтримки програмного забезпечення за принципом підписки.


1.2 Аналіз існуючих аналогів


Для обраної предметної області існує декілька систем, що мають схожий функціонал.
Для аналізу було обрано інформаційну систему «Microsoft Dynamics 365 Supply Chain Management» [1]. Функціональним призначенням зазначеного додатку є управління логістикою підприємства. Вона є частиною пакету Microsoft Dynamics 365 та надає функціональність контролю та обробки повного циклу логістики підприємства.
Перевагами даної інформаційної системи є можливість інтеграції з розумними пристроями.
Серед недоліків, пакет фокусується більше на керуванні ланцюгом постачань, аніж на управлінні конкретним складом. Також, пакет надається лише у складі пакету Microsoft 365 за щомісячну плату з великою кількістю додаткових застосунків, що можуть бути непотрібні, прямо забороняє інтеграцію з програмними пакети інших виробників. 
Також для аналізу було обрано інформаційну систему «Oracle WMS» [2]. Функціональним призначенням її є управління складськими приміщеннями. 
Серед переваг зазначеної інформаційної системи є полегшення документообігу на підприємстві складського типу. 
Серед недоліків, відсутність можливості інтеграції з розумними пристроями. Також важливим недоліком системи є погана робота служби підтримки компанії-розробника, що негативно впливає на виробничі процеси підприємств. 


1.3 Головна функціональність


Розробка є як комплексом мобільних, IoT та веб-застосунків, що надає користувачам зручний індивідуальний контроль над їх складським приміщенням.
Концепція цього проекту враховує потреби різних стейкхолдерів, зокрема керівників приміщення, працівників складу та виробників розумного пристрою. Корпоративні клієнти матимуть можливість отримати якісну підтримку програмного забезпечення та інтеграцію з їхніми власними напрацюваннями.
Система покриває основні функції та процеси, необхідні для управління складом, включаючи прийом та відвантаження товарів, зберігання товарів, переміщення товарів та відстеження товарів.
Було визначено, що ролями в системі слугуватимуть адміністратор системи, керівник складу та працівник складу.
Адміністратор системи може додавати та видаляти з системи користувачів (керівників складів та працівників), додавати та редагувати дані про посилки, додавати, видаляти та редагувати дані про склади, машини, місця зберігання, підключати та видаляти IoT-пристрій.
У веб-застосунку реалізована функціональність адміністратора системи. 
Керівник складу може створювати, редагувати та видаляти завдання для працівників з переміщення посилок, вносити інформацію про прибуття та вибуття машин, отримувати інформацію про поточний стан завдань, машин та складу, додати робочий час працівників.
Працівник може отримати дані про завдання, які він має виконати, та відмітити їх статус (виконано чи не виконано).
У мобільному застосунку реалізована функціональність керівника складу та працівника складу.
Серверний веб-застосунок проводить аутентифікацію та авторизацію за допомогою протоколу OAuth, збереження та синхронізацію даних з мобільного та веб-застосунків, проводить журналювання змін даних та комунікує з IoT пристроєм для перевірки коректності розміщення посилок. 
IoT застосунок комунікує з серверною частиною системи та за допомогою тензодатчика перевіряє наявність посилки у місці розміщення та її масу.
На основі отриманого створили діаграму прецедентів (рис. A.1).
Серед рамок наступних випусків планується реліз мобільного застосунку для операційної системи Apple iOS, додавання до системи підтримки контролю за наявністю посилки за допомогою камери та підтримка додаткових регіональних параметрів.
1.4 Робоче середовище


У якості програмної платформи для серверної частини програмного продукту використано бібліотеку Chi для мови програмування Go. У якості СКБД для проекту буде використовуватися PostgreSQL. Визначено, що база даних буде розташована в хмарі з метою захисту даних користувачів. Для клієнтського веб-застосунку використано фреймворк React для мови програмування Typescript. Для розробки IoT використано програмно-апаратний комплекс, що складається з ESP32 та Arduino SDK. У якості платформи для мобільної розробки використано фреймворк Jetpack Compose та мову програмування Kotlin. 
Також, система додатково звертається до зовнішніх API, зокрема до Google Identity API, з метою аутентифікації та авторизації, оскільки це є більш безпечним і надійним рішенням, аніж використання аутентифікації за допомогою пароля. Аутентифікація і авторизація реалізовані за допомогою протоколу Auth0, що використовує принцип зберігання інформації про користувача у форматі JWT.
У зв’язку з тим, що система є моноцентричною, були визначені додаткові обмеження щодо доступності та надійності. Сервіс має бути доступним у будь-який час. Допустиме відхилення прийнято за 1%. Сервіс має надійно й безпечно передавати та зберігати інформацію, використовуючи сучасні протоколи шифрування (зокрема, TLS) та резервного копіювання. Система, до релізу, має пройти не менш як 90% тестів.
Максимальний час отримання відповіді від серверу визначено як 3 секунди. У відповідності до визначеної архітектури програмної системи, цілісність даних у системі буде гарантуватися шляхом централізованого зберігання даних у серверній частині програмного продукту. 
2 ОПИС РОЗРОБКИ СЕРВЕРНОЇ ЧАСТИНИ СИСТЕМИ
2.1 Побудова ER-моделі даних


Надважливою задачею при розробці системи постає розробка системи типів для продукту, оскільки першочерговим завданням системи є цілісне зберігання, оновлення та видача інформації за потребою. 
Через те, що для реалізації серверної частини продукту використовується мова програмування Go, ORM GORM та СКБД PostgreSQL, то сутності будуть представлені у вигляді структур Go.
Першою описуваною структурою, є користувач системи. При створенні сутності було взято до уваги, що авторизація системи буде відбуватися за технологією Google Identity API, тому структуру їх даних було взято за основу. Структура «Користувач» зберігає інформацію про пошту, яка стане первинним ключем, ім’я та аватар користувача.
Додано тип «Тип користувача» на основі базового типу рядок. Додано декілька констант, що відображають можливі значення даного типу. 
Додано структуру «Посилка». Вона зберігає дані про ідентифікатор, назву, опис, та пов’язана з місцем розміщення зв’язком «один-до-одного» (див. додаток Б.6).
Додано структуру «Пристрій». Вона зберігає дані про ідентифікатор та пов’язана з місцем розміщення зв’язком «один-до-одного».
Додано структуру «Результат вимірювання». Вона зберігає дані про ідентифікатор, вагу під час виміру, час виміру та пов’язана з місцем розміщення зв’язком «один-до-багатьох».
Додано структуру «Місце розміщення». Вона зберігає дані про ідентифікатор та пов’язана з сховищем зв’язком «один-до-багатьох».
Додано структуру «Сховище». Вона зберігає дані про ідентифікатор, тип сховища та пов’язана з складом або машиною зв’язком «один-до-одного».
Додано тип «Тип сховища» на основі базового типу рядок. Додано декілька констант, що відображають можливі значення даного типу. 
Додано структуру «Склад». Вона зберігає дані про ідентифікатор та пов’язана з менеджером зв’язком «один до одного».
Додано структуру «Менеджер». Вона зберігає дані про ідентифікатор та пов’язана зі складом та користувачем зв’язком «один до одного».
Додано структуру «Працівник». Вона зберігає дані про ідентифікатор та пов’язано з розкладом та складом зв’язком «один до багатьох».
Додано структуру «Розклад». Вона зберігає дані про ідентифікатор, час початку роботи та кінця роботи і пов’язана з працівником зв’язком «один до багатьох».
Додано структуру «Машина», що зберігає інформацію про ідентифікатор, та пов’язана зі складом та користувачем зв’язком «один до одного».
Додано структуру «Переміщення», що зберігає інформацію про ідентифікатор, початок та кінець часу розміщення на складі, та пов’язана зі складом зв’язком «один до одного» та з машиною зв’язком «один до багатьох».
Додано структуру «Завдання», що зберігає інформацію про ідентифікатор та статус завдання, та пов’язана з місцем розміщення зв’язком «один до одного» та з працівником зв’язком «один до багатьох».
На основі отриманих структур створили ER-модель даних (рис. А.2).


2.2 Опис архітектури серверної частини програмної системи


Архітектура серверної частини застосунку побудована за принципом N-рівневої архітектури. Основні рівні представлені: рівнем представлення, рівнем бізнес-логіки, рівнем доступу до даних. Присутні також два додаткових частини: службові компоненти та моделі.
На рівні представлення серверна частина програмного продукту отримує зовнішні запити до API, передає дані у бізнес-логіку і повертає результат користувачу. У якості серверної бібліотеки використовується бібліотека Chi для мови програмування Go.
На рівні бізнес-логіки виконуються основні операції над даними. У разі потреби в отриманні чи збереженні даних, виконується виклик методів рівня доступу до даних.
Рівень доступу до даних взаємодіє з базою даних, отримує та зберігає інформацію. Зазначений рівень було побудовано з використанням патерну «Репозиторій», для його абстрагування від бізнес-логіки. Під час взаємодії з БД використовується ORM GORM для мови програмування Go.
Службовими компонентами у застосунку є сервіс логування та сервіс конфігурації застосунку. Вони засновані на інструментах стандартної бібліотеки мови програмування Go.
Моделі визначають структури даних, що використовуються на всіх рівнях абстракції.


2.3 Опис взаємодії з іншими частинами системи


Постає задача з проектування взаємодії частин системи.
Клієнтський веб-застосунок буде виконуватися у браузері, виконуючи запити до сервера, де розміщений код та розмітка веб-застосунку. Зв’язок з серверною частиною програмного продукту буде виконуватися за допомогою асинхронних HTTPS запитів, що будуть непомітні для користувача. Також, за допомогою перенаправлень, будуть викликатися методи Google Identity API, у разі необхідності.
Мобільний застосунок під час виконання нативно на цільовій платформі буде здійснювати асинхронні HTTPS запити, що будуть непомітні для користувача, для зв’язку з серверною частиною системи.
IoT пристрій буде виконувати регулярні HTTPS запити за принципом Long Polling для сихронізації даних з серверною частиною програмної системи.
Серверна частина системи буде мати ексклюзивний зв’язок з базою даних, що буде підтримуватися за рахунок постійних TCP/TLS з’єднань.
На основі одержаного створили діаграму розгортання (рис. А.3).


2.4 Опис структури коду серверної частини системи


Після проектування архітектури серверної частини програмного продукту була визначена структура пакетів проекту.
Головним пакетом програми у мові програмування Go є пакет main. У ньому відбувається імпорт, ініціалізація та виконання всіх інших пакетів. Також у ньому визначено REST специфікацію проекту.
Рівень представлення представлений пакетом handlers. У ньому зберігаються всі інші підпакети, що використовуються для отримання запитів та надсилання відповіді.
Рівень бізнес-логіки: пакет services. У ньому зберігаються всі інші підпакети, що використовуються для виконання бізнес-логіки.
Рівень доступу до даний: пакет storage, де зберігається код взаємодії з базою даних.
Службові компоненти: пакет internal. В ньому визначений сервіс логування та сервіс конфігурації системи.
Моделі: пакет types.
На основі отриманих структур створили діаграму пакетів (рис. А.4).
2.5 Специфікація REST


Після розробки серверної частини програмного продукту була визначена наступна специфікація REST:
–	POST /login: endpoint for user login;
–	POST /register/device: endpoint for registering a new device;
–	DELETE /register/device: endpoint for deleting a registered device;
–	POST /register/manager: endpoint for registering a new manager;
–	GET /register/manager/all: endpoint for getting all registered managers;
–	POST /register/worker: endpoint for registering a new worker;
–	DELETE /register/worker: endpoint for deleting a registered worker;
–	POST /admin/car: endpoint for adding a new car;
–	DELETE /admin/car: endpoint for deleting a car;
–	GET /admin/car: endpoint for getting a car;
–	POST /admin/item: endpoint for adding a new item;
–	PUT /admin/item: endpoint for updating an item;
–	POST /admin/warehouse: endpoint for adding a new warehouse;
–	DELETE /admin/warehouse: endpoint for deleting a warehouse;
–	GET /admin/warehouse: endpoint for getting a warehouse;
–	POST /admin/slot: endpoint for adding a new slot;
–	DELETE /admin/slot: endpoint for deleting a slot;
–	GET /admin/slot: endpoint for getting a slot;
–	PUT /admin/slot: endpoint for updating a slot;
–	GET /manager/car/all: endpoint for getting all cars;
–	POST /manager/task: endpoint for adding a new task;
–	GET /manager/task: endpoint for getting a task;
–	GET /manager/task/all: endpoint for getting all tasks;
–	DELETE /manager/task: endpoint for deleting a task;
–	POST /manager/timetable: endpoint for adding to timetable;
–	POST /manager/transfer: endpoint for adding a new transfer;
–	GET /manager/transfer/all: endpoint for getting all transfers;
–	POST /manager/connect: endpoint for connecting a device;
–	POST /device/polling: endpoint for device polling;
–	GET /worker/task: endpoint for getting tasks;
–	POST /worker/task: endpoint for setting a task as done.
 
3 ОПИС РОЗРОБКИ ЗАСТОСУНКУ ДЛЯ ВБУДОВНИХ СИСТЕМ
3.1 Концептуальне моделювання застосунку	


Перед розробкою частини системи для вбудованих систем необхідно провести концептуальне моделювання.
Відповідно, пристрою необхідно мати можливість зчитувати дані з тензодатчика, виводити фактичну та еталонну вагу на екран, підсвічувати світлодіод з заданою яскравістю за допомогою ШІМ, передавати фактичну вагу до серверу та отримувати еталонну вагу предмету.


3.2 Обґрунтування архітектурних рішень


Під час розробки було визначено, що архітектурною основою застосунку для вбудованих систем стане монолітна архітектура. Таке рішення дозволило значно покращити продуктивність продукту та пришвидшити розробку. 
Визначено, що робота з пристроями та комунікація з сервером виконуватимуться послідовно.
Налаштування та конфігурація будуть зберігатися у окремому заголовкому файлі та підвантажуватися в момент компіляції застосунку.
Було вирішено, що комунікація між серверною частиною та застосунком для вбудованих систем буде виконуватися за принципом Long Polling, що полягає у виконанні запитів контролером кожен чітко окреслений проміжок часу для синхронізації інформації. Такий підхід спрощує реалізацію комунікації між пристроєм та серверною частиною проекту та дозволяє не підтримувати постійний зв’язок, що зменшує навантаження та збільшує можливості щодо масштабування системи.
Під час обміну даних пристрій має відправляти на сервер свій токен, отриманий з файлу конфігурації, та фактичну вагу предмета. У відповідь, контролер від сервісу отримує еталонну вагу предмета.
Для отримання і виведення даних, буде використаний тензодатчик, екран, та світлодіод.
Результатом прийнятих архітектурних рішень стала UML діаграма  діяльності (рис. А.5). 


3.3 Опис використаних технологій


Прототипування системи виконувалося з розрахунку, що система має запускатися та функціонувати на ESP32 з використанням Arduino SDK. Під час розробки вбудованої частини системи був використаний інструмент Wokwi у якості IDE для зазначеної платформи.
У якості тензодатчика було використано HX711 у модифікації з підтримкою ваги до 50 кілограмів.
У якості екрану, було використано LCD екран LiquidCrystal у модифікації 16х2 (16 символів у ряді, 2 рядки).
Для обміну даними з сервером було використано HTTPClient стандартної бібліотеки ESP32 та зовнішній пакет ArduinoJson для кодування й декодування тіла запитів.
Для роботи з ШІМ, Wi-Fi та часовими параметрами використовувалися засоби стандартної бібліотеки ESP32.
Для демонстрації структури використання пакетів усередині системи була розроблена UML діаграма пакетів (див. додаток А.3).


3.4 Опис результатів розробки застосунку для вбудованих систем


Результатом роботи став застосунок для вбудованих систем, що реалізований для пристрою ESP32.
Під час запуску додатку, спершу відбувається його ініціалізація та підготовка. Під час цього етапу виконується ініціалізація LCD-екрану, Wi-Fi, тензодатчика, світлодіода, системи роботи з часом.
Після ініціалізації, система циклічно виконує головну функцію програми кожні 2 секунди.
У головній частині програми, виконується зважування предмету за допомогою тензодатчика. Після цього, з метою ефективного налагодження застосунку у разі несправностей, система виводить до консолі порту налагоджування фактичну масу. 
Далі, застосунок виконує запит до сервера, в якому за допомогою ArduinoJSON кодує результат зважування та час зважування. У результаті запиту, застосунок отримує еталонний показник ваги, з яким буде виконуватися порівняння. 
Після цього відбувається розрахунок різниці за модулем між фактичною та еталонною вагою та переведення її у межі від 0 до 255. Даний показник буде названий яскравістю. 
Далі, за допомогою ШІМ, застосунок задає світлодіоду отриману яскравість. Таким чиною, чим більшою є різниця між фактичним та еталонним показниками, тип яскравіше світиться світлодіод.
Після цього, застосунок передає фактичну та еталону вагу на екран, для їх відображення.
Для демонстрації структури проекту була розроблена UML діаграма взаємодії (рис. А.6).

3.5 Опис результатів тестування застосунку для вбудованих систем


Для перевірки правильності роботи застосунку було проведено функціональне тестування. Тестування виконувалося вручну, за допомогою спеціального програмного забезпечення, а також з використання програмних методів. У ході тестування було використано функціональність Wokwi, як емулятора ESP32, та датчиків.
Налаштування Wi-Fi були задані у конфігураційному файлі відповідним до вимог Wokwi для емуляції роботи відповідного модуля чином.
Віртуальна фактична вага визначається за допомогою інтерфейсу емулятора. Важливо зазначити, що під час ініціалізації початковим значенням ваги має бути «0» для правильної роботи тензодатчика впродовж подальшого виконання.
Робота світлодіода, екрана та консолі налагоджування відображені у графічному інтерфейсі Wokwi.
 
4 ОПИС РОЗРОБКИ КЛІЄНТСЬКОЇ ЧАСТИНИ СИСТЕМИ
4.1 Концептуальне моделювання застосунку	


Адміністратор системи повинен мати можливість додавати та видаляти сховища, машини; додавати, видаляти й редагувати місця зберігання; додавати та редагувати товари; додавати та видаляти працівників сховищ; додавати менеджерів складу. Крім того, адміністратор повинен мати можливість переглядати зазначені структури.


4.2 Обґрунтування архітектурних рішень


Під час розробки було визначено, що архітектурною основою клієнтського застосунку стане змішана архітектура на основі компонентно-орієнтованої архітектури. Таке рішення дозволило значно покращити масштабованість та пришвидшити розробку застосунку. 
Кожна частина застосунку визначена у вигляді компонента – напівзалежної частини, двобічна комунікація якої з іншими компонентами обмежена. Це дозволяє розділити програму на логічні частини і підвищує якість коду.
Конфігурація застосунку зберігається в окремому файлі та завантажується під час збірки застосунку.
Обмін даними між серверною та клієнтською частиною програми виконується шляхом виконання асинхронних запитів до сервера за завчасно заданими шляхами, для обміну даних. Синхронізація даних покладена на серверну частину системи.
Авторизація виконується за протоколом Auth0, за допомогою токена JWT. 
Застосунок підтримує українську та англійську мови інтерфейсів.
Результатом прийнятих архітектурних рішень стала UML діаграма компонент (рис. А.7).


4.3 Опис використаних технологій


Розробка застосунку виконана за допомогою мови програмування TypeScript та веб-бібліотеки React. У якості стилізованої компонентної бібліотеки використовувалася бібліотека MUI. 
Для авторизації використовувалася бібліотека Google Identity SDK. Середовищем виконання слугувало NodeJS.
У якості інструменту інтернаціоналізації та локалізації було використано бібліотеку react-i18next.
Для демонстрації структури використання пакетів усередині системи була розроблена UML діаграма пакетів (рис. А.4).


4.4 Опис результатів розробки клієнтської частини системи


Результатом роботи став клієнтський веб-застосунок.
Під час запуску додатку, спершу на екран виводиться пропозиція авторизуватися за допомогою Google.
Після авторизації, користувач потрапляє на головну сторінку застосунку. Застосунок має три вкладки: «Сховища», «Машини» та «Менеджери». За замовчування, користувач автоматично потрапляє у розділ «Сховища».
Кожен розділ відповідає за власну структуру даних та всі вкладені до неї, наприклад, у розділі «Сховища» можна керувати сховищами, працівниками складу, місцями зберігання, товарами; у розділі «Машини»: машинами, місцями зберігання, товарами; у розділі «Менеджери»: вільними менеджерами.
У верхній панелі, що доступна на всіх сторінках застосунку, присутні клавіши «UA» та «EN» для перемикання мови застосунку.
Після введення даних до будь-якої форми, що доступна у застосунку, дані збережуться лише в разі натискання кнопки підтвердження. Це зроблено для захисту користувача від ненавмисного паплюження даних. 
Валідація даних відбувається на рівні браузера стандартними інструментами HTML5.
Для демонстрації структури проекту була розроблена UML діаграма діяльності (рис. А.5).


4.5 Опис результатів тестування клієнтської частини системи


Для перевірки правильності роботи застосунку було проведено  функціональне тестування. Тестування виконувалося вручну, за допомогою спеціального програмного забезпечення, а також з використання програмних методів. У ході тестування було використано функціональність браузерів Google Chrome, Mozilla Firefox та IDE Jetbrains Webstorm. 
5 ОПИС РОЗРОБКИ МОБІЛЬНОЇ ЧАСТИНИ СИСТЕМИ
5.1 Концептуальне моделювання застосунку	


Керівник складу може створювати та видаляти завдання для працівників з переміщення посилок, вносити інформацію про прибуття та вибуття машин, отримувати інформацію про поточний стан завдань, машин та складу, додати робочий час працівників.
Працівник може отримати дані про завдання, які він має виконати, та відмітити їх статус (виконано чи не виконано).


5.2 Обґрунтування архітектурних рішень


Під час розробки було визначено, що архітектурною основою клієнтського застосунку стане змішана архітектура на основі компонентно-орієнтованої архітектури з використанням патерну Model-View-ViewModel (MVVM). Таке рішення дозволило значно покращити продуктивність продукту та швидкість розробки застосунку. 
Кожна незалежна частина системи написана у вигляді компонента. Логіка взаємодії з серверною частиною застосунку винесена окремо від коду інтерфейсу застосунку, у моделі представлення. Це дозволяє розділити застосунок на логічні частини і підвищує якість коду.
Конфігурація зберігається у окремому файлі та завантажуватися під час збірки застосунку.
Обмін даних між серверною та мобільною частиною програми виконується за допомогою виконання асинхронних запитів до серверу за завчасно заданими шляхами, для обміну даних. Синхронізація даних повністю покладена на серверну частину системи.
Авторизація виконується за протоколом Auth0, за допомогою токена JWT. 
Застосунок підтримує українську та англійську мови інтерфейсу.
Результатом прийнятих архітектурних рішень стала UML діаграма  компонент (рис. А.7).


5.3 Опис використаних технологій


Застосунок розроблено з використанням мови програмування Kotlin та фреймворка Android Jetpack Compose.
У процесі розробки використовувалися компоненти інтерфейсу бібліотеки Android Jetpack Material3.
Для авторизації використовувалася бібліотека Google Identity SDK. 
Для демонстрації структури використання пакетів усередині системи була розроблена UML діаграма пакетів (рис. А.4).


5.4 Опис результатів розробки мобільного застосунку


Результатом роботи став мобільний застосунок.
Під час запуску додатку, спершу на екран виводиться пропозиція авторизуватися за допомогою Google.
Після авторизації, користувач потрапляє на головну сторінку застосунку. 
У інтерфейсі для керівника складу застосунок має чотири вкладки: «Сховище», «Машини» та «Завдання» та «Працівники». За замовчування, користувач потрапляє у розділ «Сховище».
Кожен розділ відповідає за свою структуру даних та всі вкладені в неї. У розділі «Сховища» можна керувати місцями зберігання, товарами; у розділі «Машини»: машинами, місцями зберігання, товарами, переміщеннями; у розділі «Завдання»: завданнями, у розділі «Працівники»: робочим днем працівників.
У верхній панелі, що доступна у всіх розділах застосунку, присутня кнопка для перемикання мови застосунку.
Після введення даних у форми, що доступні у застосунку, дані збережуться лише в разі підтвердження. Це зроблено для захисту користувача від ненавмисного паплюження даних. 
Валідація даних відбувається на рівні компонентів Android Jetpack Material3 та у серверній частині застосунку.


5.5 Опис результатів тестування мобільного застосунку


Для перевірки правильності роботи застосунку було проведено функціональне тестування. Тестування виконувалося вручну, за допомогою спеціального програмного забезпечення, а також з використанням програмних методів. У ході тестування було використано функціональність IDE Android Studio.
 
ВИСНОВКИ


На етапі аналізу та концептуального моделювання предметної області під час курсового проектування було проведено виявлення бізнес-можливостей, проаналізовано існуючі аналоги, проілюстровано його позитивні та негативні риси. Було сформовано чіткі вимоги до головної функціональності та визначено робоче середовище.
На етапі розробки серверної частини системи було побудовано ER-модель даних, описано її архітектуру, принципи взаємодії з іншими частинами системи, структуру коду. Було визначено специфікацію REST.
На етапі розробки застосунку для вбудованих систем, клієнтської частини системи та мобільного застосунку було проведено концептуальне моделювання відповідного застосунку, описано та обґрунтовано архітектурні рішення. Було описано використані технології, результати розробки відповідної частини системи.
В результаті була створена програмна система для управління складом, що складається з серверної, клієнтської, мобільної частин та частини для вбудованих систем з використанням бібліотеки Chi для Go, СКБД PostgreSQL, клієнтської бібліотека React для Typescript, Arduino SDK для ESP32, фреймворка Jetpack Compose для Kotlin у якості технологій розробки, та Jetbrains Goland, Jetbrains Webstorm, Google Android Studio та Wokwi у якості середовищ розробки.

 
ПЕРЕЛІК ВИКОРИСТАНИХ ДЖЕРЕЛ


1.	Microsoft Dynamics 365 Supply Chain Management / Завантаження. URL: https://www.microsoft.com/en-us/dynamics-365/products/supply-chain-management (дата звернення: 14.06.2024).
2.	Oracle WMS / Завантаження. URL: https://www.oracle.com/scm/logistics/warehouse-management/ (дата звернення: 14.06.2024).
3.	Репозиторій реалізованої програмної системи. URL: https://github.com/NureButsulinIhor/apzkr-pzpi-21-2-butsulin-ihor.git (дата звернення: 14.06.2024).
4.	Відеозапис функціонального тестування розробленої програмної системи. URL: https://youtu.be/YNLvjw0-x0E (дата звернення: 14.06.2024). 
ДОДАТОК А
Діаграми


 
Рисунок А.1 — UML діаграма прецедентів
Продовження додатку А
 
Рисунок А.2 — ER-модель даних


 
Продовження додатку А
 
Рисунок А.3 — Діаграма розгортання

 

Продовження додатку А
 
 
 
 
Рисунок А.4 —  UML діаграма пакетів
Продовження додатку А
 
 
Рисунок А.5 — UML діаграма діяльності
Продовження додатку А
 
Рисунок А.6 — UML діаграма взаємодії
 
Продовження додатку А
 
 
Рисунок А.7 — UML діаграма компонент
 
ДОДАТОК Б
Фрагменти коду програми


Б.1 Стартовий файл серверної частини системи


1  package main
2  
3  import (
4  	"apz-backend/handlers/admin"
5  	"apz-backend/handlers/device"
6  	"apz-backend/handlers/manager"
7  	"apz-backend/handlers/oauth"
8  	"apz-backend/handlers/register"
9  	"apz-backend/handlers/worker"
10  	"apz-backend/internal/config"
11  	"apz-backend/internal/log"
12  	"apz-backend/storage/gormstorage"
13  	"github.com/go-chi/chi/v5"
14  	"github.com/go-chi/chi/v5/middleware"
15  	"github.com/go-chi/jwtauth/v5"
16  	"log/slog"
17  	"net/http"
18  	"time"
19  )
20  
21  func main() {
22  	cfg := config.NewConfig()
23  
24  	// Logger
25  	logger, writeCloser := log.NewLogger(cfg.BuildMode, cfg.IsConsoleLogger, cfg.LogFilePath)
26  	defer writeCloser.Close()
27  	logger.Info("Logger initialised")
28  
29  	// Storage
30  	storage, err := gormstorage.NewStorage(cfg.ConnectionString)
31  	if err != nil {
32  		logger.Error(err.Error())
33  		return
34  	}
35  	_ = storage
36  
37  	// Auth
38  	tokenAuth := jwtauth.New("HS256", []byte(cfg.AuthSecret), nil)
39  	_ = tokenAuth
40  
41  	// Router
42  	r := chi.NewRouter()
43  
44  	r.Use(middleware.RequestID)
45  	r.Use(middleware.RealIP)
46  	r.Use(middleware.Recoverer)
47  	r.Use(middleware.Timeout(60 * time.Second))
48  
49  	// Routes
50  	// Without auth
51  	r.Route("/login", func(r chi.Router) {
52  		r.Post("/", oauth.Login(logger, tokenAuth, cfg.GoogleClientID, storage))
53  	})
54  
55  	// Admin routes group
56  	r.Route("/register", func(r chi.Router) {
57  		r.Use(jwtauth.Verifier(tokenAuth))
58  		r.Use(jwtauth.Authenticator(tokenAuth))
59  
60  		r.Route("/device", func(r chi.Router) {
61  			r.Post("/", register.Device(logger, tokenAuth, storage))
62  			r.Delete("/", register.DeleteDevice(logger, tokenAuth, storage))
63  		})
64  
65  		r.Route("/manager", func(r chi.Router) {
66  			r.Post("/", register.Manager(logger, tokenAuth, storage))
67  			r.Get("/all", register.GetManagers(logger, tokenAuth, storage))
68  		})
69  
70  		r.Route("/worker", func(r chi.Router) {
71  			r.Post("/", register.Worker(logger, tokenAuth, storage))
72  			r.Delete("/", register.DeleteWorker(logger, tokenAuth, storage))
73  		})
74  
75  	})
76  
77  	r.Route("/admin", func(r chi.Router) {
78  		r.Use(jwtauth.Verifier(tokenAuth))
79  		r.Use(jwtauth.Authenticator(tokenAuth))
80  
81  		r.Route("/car", func(r chi.Router) {
82  			r.Post("/", admin.AddCar(logger, storage))
83  			r.Delete("/", admin.DeleteCar(logger, storage))
84  			r.Get("/", admin.GetCar(logger, storage))
85  		})
86  
87  		r.Route("/item", func(r chi.Router) {
88  			r.Post("/", admin.AddItem(logger, storage))
89  			r.Put("/", admin.UpdateItem(logger, storage))
90  		})
91  
92  		r.Route("/warehouse", func(r chi.Router) {
93  			r.Post("/", admin.AddWarehouse(logger, storage))
94  			r.Delete("/", admin.DeleteWarehouse(logger, storage))
95  			r.Get("/", admin.GetWarehouse(logger, storage))
96  		})
97  
98  		r.Route("/slot", func(r chi.Router) {
99  			r.Post("/", admin.AddSlot(logger, storage))
100  			r.Delete("/", admin.DeleteSlot(logger, storage))
101  			r.Get("/", admin.GetSlot(logger, storage))
102  			r.Put("/", admin.UpdateSlot(logger, storage))
103  		})
104  	})
105  
106  	// Manager routes group
107  	r.Route("/manager", func(r chi.Router) {
108  		r.Use(jwtauth.Verifier(tokenAuth))
109  		r.Use(jwtauth.Authenticator(tokenAuth))
110  
111  		r.Route("/car", func(r chi.Router) {
112  			r.Get("/all", manager.GetCars(logger, storage))
113  		})
114  
115  		r.Route("/task", func(r chi.Router) {
116  			r.Post("/", manager.AddTask(logger, storage))
117  			r.Get("/", manager.GetTask(logger, storage))
118  			r.Get("/all", manager.GetTasks(logger, storage))
119  			r.Delete("/", manager.DeleteTask(logger, storage))
120  		})
121  
122  		r.Route("/timetable", func(r chi.Router) {
123  			r.Post("/", manager.AddToTimetable(logger, storage))
124  		})
125  
126  		r.Route("/transfer", func(r chi.Router) {
127  			r.Post("/", manager.AddTransfer(logger, storage))
128  			r.Get("/all", manager.GetTransfers(logger, storage))
129  		})
130  
131  		r.Route("/connect", func(r chi.Router) {
132  			r.Post("/", manager.ConnectDevice(logger, storage))
133  		})
134  	})
135  
136  	// Device routes group
137  	r.Route("/device", func(r chi.Router) {
138  		r.Use(jwtauth.Verifier(tokenAuth))
139  		r.Use(jwtauth.Authenticator(tokenAuth))
140  
141  		r.Post("/polling", device.Polling(logger, storage))
142  	})
143  
144  	// Worker routes group
145  	r.Route("/worker", func(r chi.Router) {
146  		r.Use(jwtauth.Verifier(tokenAuth))
147  		r.Use(jwtauth.Authenticator(tokenAuth))
148  
149  		r.Route("/task", func(r chi.Router) {
150  			r.Get("/", worker.GetTasks(logger, storage))
151  			r.Post("/", worker.SetDone(logger, storage))
152  		})
153  	})
154  
155  	// Server
156  	server := &http.Server{
157  		Addr:              cfg.URL,
158  		Handler:           r,
159  		ReadHeaderTimeout: time.Duration(cfg.Timeout) * time.Second,
160  	}
161  
162  	// Start server
163  	logger.Info("Starting server...", slog.String("url", cfg.URL))
164  	err = server.ListenAndServe()
165  	if err != nil {
166  		logger.Error(err.Error())
167  	}
168  }


Б.2 Файл сервісу аутентифікації серверної частини системи


1  package login
2  
3  import (
4  	"apz-backend/types/models"
5  	"cloud.google.com/go/auth/credentials/idtoken"
6  	"context"
7  	"errors"
8  	"github.com/go-chi/jwtauth/v5"
9  	"log/slog"
10  )
11  
12  type UserGetter interface {
13  	GetUserByEmail(email string) (*models.User, error)
14  	UpdateUserData(user *models.User) error
15  }
16  
17  type Configuration struct {
18  	UserGetter UserGetter
19  	Logger     *slog.Logger
20  	Context    context.Context
21  	JWTAuth    *jwtauth.JWTAuth
22  }
23  
24  func Google(googleJWT string, clientID string, cfg Configuration) (string, error) {
25  	l := cfg.Logger.With(
26  		slog.String("op", "services.login.Google"),
27  	)
28  
29  	l.Debug("processing jwt from Google")
30  	payload, err := idtoken.Validate(cfg.Context, googleJWT, clientID)
31  	if err != nil {
32  		l.Debug("err to parse jwt from Google")
33  		return "", errors.New("invalid JWT token")
34  	}
35  
36  	l.Debug("processing claims")
37  	claimsUser, err := models.NewUserFromClaims(payload.Claims)
38  	if err != nil {
39  		l.Debug("err to parse claims from Google")
40  		return "", errors.New("invalid JWT token")
41  	}
42  
43  	l.Debug("getting user from db")
44  	user, err := cfg.UserGetter.GetUserByEmail(claimsUser.Email)
45  	if err != nil {
46  		l.Debug("err to get user from db")
47  		return "", errors.New("no user found")
48  	}
49  
50  	l.Debug("updating user data")
51  	user.Name = claimsUser.Name
52  	user.Picture = claimsUser.Picture
53  	err = cfg.UserGetter.UpdateUserData(user)
54  	if err != nil {
55  		l.Error("err to update user data", slog.String("error", err.Error()))
56  		return "", errors.New("internal error")
57  	}
58  
59  	l.Debug("generating token")
60  	_, tokenString, err := cfg.JWTAuth.Encode(user.GetClaims())
61  	if err != nil {
62  		l.Error("err to generate token", slog.String("error", err.Error()))
63  		return "", errors.New("internal error")
64  	}
65  
66  	return tokenString, nil
67  }


Б.3 Частина коду доступу до бази даних серверної частини системи


1  package gormstorage
2  
3  import (
4  	"apz-backend/types/models"
5  	"gorm.io/gorm"
6  	"gorm.io/gorm/clause"
7  )
8  
9  func (g GormStorage) AddCar(car models.Car) (uint, error) {
10  	db := g.db
11  
12  	result := db.Create(&car)
13  
14  	return car.ID, result.Error
15  }
16  
17  func (g GormStorage) DeleteCar(carID uint) error {
18  	db := g.db
19  
20  	result := db.Delete(&models.Car{Model: gorm.Model{ID: carID}})
21  
22  	return result.Error
23  }
24  
25  func (g GormStorage) GetCar(carID uint) (*models.Car, error) {
26  	db := g.db
27  
28  	var car models.Car
29  	result := db.Preload(clause.Associations).First(&car, carID)
30  
31  	return &car, result.Error
32  }


Б.4 Код cтруктури «Користувач» серверної частини системи


1  package models
2  
3  import "gorm.io/gorm"
4  
5  type UserType string
6  
7  const (
8  	WorkerType  UserType = "worker"
9  	ManagerType UserType = "manager"
10  	AdminType   UserType = "admin"
11  )
12  
13  type User struct {
14  	gorm.Model
15  	Email   string `json:"email" gorm:"unique"`
16  	Name    string `json:"name"`
17  	Picture string `json:"picture"`
18  	Type    UserType
19  }
20  
21  func NewUserFromClaims(claims map[string]interface{}) (user User, err error) {
22  	defer func() {
23  		if r := recover(); r != nil {
24  			err = r.(error)
25  		}
26  	}()
27  
28  	id := uint(claims["id"].(float64))
29  	email := claims["email"].(string)
30  	name := claims["name"].(string)
31  	picture := claims["picture"].(string)
32  	userType := UserType(claims["type"].(string))
33  
34  	return User{
35  		Model:   gorm.Model{ID: id},
36  		Email:   email,
37  		Name:    name,
38  		Picture: picture,
39  		Type:    userType,
40  	}, err
41  }
42  
43  func (u User) GetClaims() map[string]interface{} {
44  	return map[string]interface{}{
45  		"email":   u.Email,
46  		"name":    u.Name,
47  		"picture": u.Picture,
48  		"type":    u.Type,
49  	}
50  }

Б.5 Ініціалізація програми застосунку для вбудованих систем


1  void setup() {
2    Serial.begin(115200);
3  
4    Serial.println("Initializing LCD...");
5    lcd.begin(LcdConf1, LcdConf2);
6    lcd.print("Starting...");
7  
8    Serial.println("Connecting to WiFi...");
9    WiFi.begin(WiFiSsid, WiFiPassword, 6);
10    while (WiFi.status() != WL_CONNECTED) {
11      delay(250);
12      Serial.println("Connecting to WiFi...");
13    }
14    Serial.println("WiFi connected");
15    Serial.print("IP address: ");
16    Serial.println(WiFi.localIP());
17  
18    Serial.println("Initializing HX711...");
19    hx.begin(DataPinHX711, ScanPinHX711);
20    hx.set_scale(420);
21    hx.tare();
22  
23    Serial.println("Initializing LED...");
24    ledcSetup(PwmChannel, PwmFrequency, PwmResolution);
25    ledcAttachPin(LedPin, PwmChannel);
26  
27    Serial.println("Initializing Time...");
28    configTime(UTC_OFFSET, UTC_OFFSET_DST, NTP_SERVER);
29    char formattedTime[40];
30    getTime(formattedTime, 40);
31    Serial.println("Local time: " + String(formattedTime)); 
32  
33    Serial.println("End of setup.");
34    lcd.clear();
35    lcd.print("Started!");
36  }


Б.6 Головний цикл застосунку для вбудованих систем



1  void loop() {
2    
3    double realWeight = hx.get_units(10);
4    Serial.printf("Real weight: %.2F\n", realWeight);
5  
6    double referenceWeight = fetch(realWeight);
7    Serial.printf("Reference weight: %.2F\n", referenceWeight);
8  
9    int brightness = abs(referenceWeight - realWeight) * 5.1;
10    Serial.printf("Brightness: %d\n", brightness);
11  
12    ledcWrite(PwmChannel, brightness); // From 0 to 255
13    printToMon(realWeight, referenceWeight);
14  
15    delay(2000);
16  } 


Б.7 Конфігураційний файл застосунку для вбудованих систем


1  #define NTP_SERVER     "pool.ntp.org"
2  #define UTC_OFFSET     3600
3  #define UTC_OFFSET_DST 0
4  
5  const int DataPinHX711 = 32;
6  const int ScanPinHX711 = 33;
7  
8  const int PwmChannel = 0;
9  const int PwmFrequency = 5000; // 5 kHz frequency
10  const int PwmResolution = 8; // 8-bit resolution (values from 0 to 255)
11  
12  const int LcdPinRS = 19;
13  const int LcdPinE = 18;
14  const int LcdPinD4 = 5;
15  const int LcdPinD5 = 17;
16  const int LcdPinD6 = 16;
17  const int LcdPinD7 = 4;
18  const int LcdConf1 = 16;
19  const int LcdConf2 = 2;
20  
21  const int LedPin = 23;
22  
23  // User should change this.
24  const String WiFiSsid = "Wokwi-GUEST";
25  const String WiFiPassword = "";
26  const String ServerURL = "http://91.211.15.6:63784/";
27  const String AuthBearer = "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImEzYTMyNjFkLTY0MGUtNGMxYy04MjE3LTE5MjQ1MDZjZjc2NiJ9.gcDKrAxmJAxXu9xISCyg2i0_2QoZOe-dJhVuB1bEjpg";


Б.8 Ініціалізація клієнтської частини системи


1  import React from 'react'
2  import ReactDOM from 'react-dom/client'
3  import {
4      createBrowserRouter,
5      RouterProvider,
6  } from "react-router-dom";
7  import App from "./App";
8  import "./utils/i18n.ts";
9  
10  const router = createBrowserRouter([
11      { path: "*", element: <App /> },
12  ]);
13  
14  ReactDOM.createRoot(document.getElementById('root')!).render(
15    <React.StrictMode>
16        <RouterProvider router={router} />
17    </React.StrictMode>,
18  ) 


Б.9 Головний компонент клієнтської частини системи


1  import {Route, Routes} from "react-router-dom";
2  import {useState} from "react";
3  import Layout from "./Layout.tsx";
4  import UnauthorisedHeader from "./components/UnauthorisedHeader/UnauthorisedHeader.tsx";
5  import Login from "./routes/Login.tsx";
6  import AuthorisedHeader from "./components/AuthorisedHeader/AuthorisedHeader.tsx";
7  import Index from "./routes/Index.tsx";
8  import AuthContext from "./utils/auth.ts";
9  import Warehouse from "./routes/Warehouse.tsx";
10  import Slot from "./routes/Slot.tsx";
11  import Cars from "./routes/Cars.tsx";
12  import Car from "./routes/Car.tsx";
13  import Managers from "./routes/Managers.tsx";
14  
15  export default function App() {
16      const [userToken, setUserToken] = useState("");
17  
18      function isUserAuthorised() {
19          return userToken !== "" && userToken !== null && userToken !== undefined;
20      }
21  
22      return (
23          <Routes>
24              {isUserAuthorised()
25                  ? <Route element={
26                      <Layout>
27                          <AuthorisedHeader/>
28                      </Layout>
29                  }>
30                      <Route path="/" element={<AuthContext.Provider value={userToken}><Index/></AuthContext.Provider>} />
31                      <Route path="/warehouse/:warehouseID" element={<AuthContext.Provider value={userToken}><Warehouse /> </AuthContext.Provider>} />
32                      <Route path="/cars" element={<AuthContext.Provider value={userToken}><Cars/></AuthContext.Provider>} />
33                      <Route path="/managers" element={<AuthContext.Provider value={userToken}><Managers/></AuthContext.Provider>} />
34                      <Route path="/warehouse/:warehouseID" element={<AuthContext.Provider value={userToken}><Warehouse /> </AuthContext.Provider>} />
35                      <Route path="/car/:carID" element={<AuthContext.Provider value={userToken}><Car /> </AuthContext.Provider>} />
36                      <Route path="/slot/:slotID" element={<AuthContext.Provider value={userToken}><Slot /> </AuthContext.Provider>} />
37                  </Route>
38                  : <Route element={
39                      <Layout>
40                          <UnauthorisedHeader/>
41                      </Layout>
42                  }>
43                      <Route path="/" element={<Login  setUserToken={setUserToken}/>} />
44                  </Route>
45              }
46          </Routes>
47      );
48  } 


Б.10 Ініціалізація мобільної частини системи


1  package com.osigram.apz2024.mobile
2  
3  import android.os.Bundle
4  import androidx.activity.ComponentActivity
5  import androidx.activity.compose.setContent
6  import androidx.activity.enableEdgeToEdge
7  import androidx.appcompat.app.AppCompatActivity
8  import androidx.appcompat.app.AppCompatDelegate
9  import androidx.compose.foundation.layout.Column
10  import androidx.compose.foundation.layout.fillMaxSize
11  import androidx.compose.foundation.layout.padding
12  import androidx.compose.material3.Scaffold
13  import androidx.compose.material3.Text
14  import androidx.compose.runtime.Composable
15  import androidx.compose.runtime.CompositionLocalProvider
16  import androidx.compose.runtime.getValue
17  import androidx.compose.runtime.mutableStateOf
18  import androidx.compose.runtime.remember
19  import androidx.compose.runtime.saveable.rememberSaveable
20  import androidx.compose.runtime.setValue
21  import androidx.compose.ui.Modifier
22  import androidx.compose.ui.res.stringResource
23  import androidx.compose.ui.tooling.preview.Preview
24  import androidx.core.os.LocaleListCompat
25  import androidx.navigation.compose.rememberNavController
26  import com.osigram.apz2024.mobile.auth.AuthData
27  import com.osigram.apz2024.mobile.auth.AuthScreen
28  import com.osigram.apz2024.mobile.auth.LocalAuth
29  import com.osigram.apz2024.mobile.manager.ManagerApp
30  import com.osigram.apz2024.mobile.ui.CardWithText
31  import com.osigram.apz2024.mobile.ui.theme.APZMobileTheme
32  import com.osigram.apz2024.mobile.worker.WorkerApp
33  
34  class MainActivity : AppCompatActivity() {
35      override fun onCreate(savedInstanceState: Bundle?) {
36          super.onCreate(savedInstanceState)
37          enableEdgeToEdge()
38          setContent {
39              APZMobileTheme {
40                  App()
41              }
42          }
43      }
44  }
45  
46  @Composable
47  fun App(modifier: Modifier = Modifier){
48      var authData by remember {
49          mutableStateOf(AuthData())
50      }
51      val navController = rememberNavController()
52  
53      if (authData.ID == 0L){
54          Scaffold(modifier = modifier.fillMaxSize()) { innerPadding ->
55              Column(
56                  modifier.padding(innerPadding)
57              ) {
58                  AuthScreen(setAuthData = {authData = it})
59              }
60          }
61      } else{
62          CompositionLocalProvider(LocalNavigator provides navController) {
63              CompositionLocalProvider(LocalAuth provides authData) {
64                  if (authData.type == "manager"){
65                      ManagerApp(modifier)
66                  } else if (authData.type == "worker"){
67                      WorkerApp(modifier)
68                  } else {
69                      Scaffold(modifier = modifier.fillMaxSize()) { innerPadding ->
70                          Column(modifier.padding(innerPadding)){
71                              CardWithText(text = stringResource(R.string.errWrongUserType))
72                          }
73                      }
74                  }
75              }
76          }
77      }
78  }
79  
80  @Preview(showBackground = true)
81  @Composable
82  fun AppPreview() {
83      APZMobileTheme {
84          App()
85      }
86  }


Б.11 Головний компонент мобільної частини системи


1  package com.osigram.apz2024.mobile.manager
2  
3  import android.util.Log
4  import androidx.appcompat.app.AppCompatDelegate
5  import androidx.compose.foundation.layout.Column
6  import androidx.compose.foundation.layout.fillMaxSize
7  import androidx.compose.foundation.layout.padding
8  import androidx.compose.material.icons.Icons
9  import androidx.compose.material.icons.outlined.AccountCircle
10  import androidx.compose.material.icons.outlined.Build
11  import androidx.compose.material.icons.outlined.Create
12  import androidx.compose.material.icons.outlined.Place
13  import androidx.compose.material3.Scaffold
14  import androidx.compose.runtime.Composable
15  import androidx.compose.runtime.getValue
16  import androidx.compose.runtime.mutableIntStateOf
17  import androidx.compose.runtime.mutableStateOf
18  import androidx.compose.runtime.remember
19  import androidx.compose.runtime.saveable.rememberSaveable
20  import androidx.compose.runtime.setValue
21  import androidx.compose.ui.Modifier
22  import androidx.compose.ui.res.stringResource
23  import androidx.compose.ui.tooling.preview.Preview
24  import androidx.core.os.LocaleListCompat
25  import androidx.navigation.NavGraph.Companion.findStartDestination
26  import androidx.navigation.compose.NavHost
27  import androidx.navigation.compose.composable
28  import androidx.navigation.toRoute
29  import com.osigram.apz2024.mobile.LocalNavigator
30  import com.osigram.apz2024.mobile.R
31  import com.osigram.apz2024.mobile.ui.BottomBar
32  import com.osigram.apz2024.mobile.ui.Route
33  import com.osigram.apz2024.mobile.ui.TopBar
34  
35  @Composable
36  fun ManagerApp(modifier: Modifier = Modifier) {
37      val navController = LocalNavigator.current
38      val buttons = listOf(
39          Route(text=stringResource(R.string.storage), route=StorageRoute, icon=Icons.Outlined.Place),
40          Route(text=stringResource(R.string.cars), route=CarsRoute, icon=Icons.Outlined.Build),
41          Route(text=stringResource(R.string.tasks), route=TasksRoute, icon=Icons.Outlined.Create),
42          Route(text=stringResource(R.string.workers), route=WorkersRoute, icon=Icons.Outlined.AccountCircle)
43      )
44      val onPageChange: (Route) -> Unit = {
45          navController.navigate(it.route){
46              // Pop up to the start destination of the graph to
47              // avoid building up a large stack of destinations
48              // on the back stack as users select items
49              popUpTo(navController.graph.findStartDestination().id) {
50                  saveState = true
51              }
52              // Avoid multiple copies of the same destination when
53              // reselecting the same item
54              launchSingleTop = true
55              // Restore state when reselecting a previously selected item
56              restoreState = true
57  
58          }
59      }
60  
61      var fromSlot by remember {
62          mutableStateOf(0UL)
63      }
64      val onChangeFromSlot: (ULong) -> Unit = {
65          fromSlot = it
66      }
67      var toSlot by remember {
68          mutableStateOf(0UL)
69      }
70      val onChangeToSlot: (ULong) -> Unit = {
71          toSlot = it
72      }
73  
74      val onChangeLang: () -> Unit = {
75          var locales = AppCompatDelegate.getApplicationLocales()
76          if (locales.toLanguageTags() == "en"){
77              locales = LocaleListCompat.forLanguageTags("uk")
78          } else{
79              locales = LocaleListCompat.forLanguageTags("en")
80          }
81  
82          AppCompatDelegate.setApplicationLocales(locales)
83      }
84  
85      Scaffold(
86          modifier = modifier.fillMaxSize(),
87          bottomBar = { BottomBar(buttonNames = buttons, onChange = onPageChange) },
88          topBar = {TopBar(stringResource(R.string.warehouse), {onChangeLang()}, modifier)}
89      ) { innerPadding ->
90          NavHost(navController = navController, startDestination = StorageRoute, modifier = modifier
91              .padding(innerPadding)
92              .fillMaxSize()){
93              composable<StorageRoute>{
94                  StorageScreen(fromSlot, onChangeFromSlot, toSlot, onChangeToSlot, modifier)
95              }
96              composable<CarsRoute> {
97                  CarsScreen(modifier)
98              }
99              composable<TasksRoute> {
100                  TasksScreen(fromSlot, toSlot, modifier)
101              }
102              composable<AddCarRoute> {
103                  AddCarScreen(modifier)
104              }
105              composable<TransfersListRoute> {
106                  val route: TransfersListRoute = it.toRoute()
107                  TransfersListScreen(carID = route.carID.toULong(), modifier)
108              }
109              composable<CarStorageRoute> {
110                  val route: CarStorageRoute = it.toRoute()
111                  CarStorageScreen(carID = route.carID.toULong(), fromSlot, onChangeFromSlot, toSlot, onChangeToSlot, modifier)
112              }
113              composable<AddTaskRoute> {
114                  AddTaskScreen(fromSlotID = fromSlot, onChangeFromSlot, toSlotID = toSlot, onChangeToSlot, modifier=modifier)
115              }
116              composable<WorkersRoute> {
117                  WorkersScreen(modifier)
118              }
119          }
120  
121      }
122  }
123  
124  @Preview(showBackground = true)
125  @Composable
126  fun ManagerAppPreview() {
127      ManagerApp()
128  }


